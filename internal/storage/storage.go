package storage

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"strconv"
	"time"

	"Storage/internal/cache"
	"Storage/internal/model"

	"github.com/jackc/pgx/v5"
)

var ErrProductNotFound = errors.New("product not found")

type Storage struct {
	logger *slog.Logger
	db     *pgx.Conn
	cache  *cache.Cache
}

func NewStorage(ctx context.Context, logger *slog.Logger, db *pgx.Conn) (*Storage, error) {
	if err := initDB(ctx, db); err != nil {
		return nil, fmt.Errorf("NewStorage (1): %w", err)
	}

	return &Storage{
		logger: logger,
		db:     db,
		cache:  cache.NewCache(),
	}, nil
}

const initQuery = `CREATE TABLE IF NOT EXISTS product(
	id INTEGER GENERATED BY DEFAULT as IDENTITY PRIMARY KEY,
	name TEXT NOT NULL,
	description TEXT,
	rubles INTEGER NOT NULL CHECK (rubles > 0),
	pennies INTEGER NOT NULL CHECK (pennies >= 0),
	quantity INTEGER NOT NULL CHECK (quantity >= 0),
	created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
	updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)`

func initDB(ctx context.Context, conn *pgx.Conn) error {
	_, err := conn.Exec(ctx, initQuery)
	if err != nil {
		return fmt.Errorf("initDB: %w", err)
	}
	return nil
}

const getAllQuery = `
	SELECT
	id,
	name,
	coalesce(nullif(description, ''), 'Описание отсутсвует') as description,
	rubles,
	pennies,
	quantity,
	created_at,
	updated_at
	FROM product`

func (s *Storage) GetAllProduct(ctx context.Context, conn *pgx.Conn) error {
	rows, err := conn.Query(ctx, getAllQuery)
	if err != nil {
		return fmt.Errorf("GetAllProduct (1): %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var p model.Product

		if err := rows.Scan(&p.ID, &p.Name, &p.Description, &p.Rubles, &p.Pennies, &p.Quantity, &p.CreatedAt, &p.UpdatedAt); err != nil {
			return fmt.Errorf("GetAllProduct (2): %w", err)
		}

		s.cache.Set(strconv.Itoa(p.ID), &p)
	}

	s.logger.Info("All data upload in cache")

	if err := rows.Err(); err != nil {
		return fmt.Errorf("GetAllProduct (3): %w", err)
	}

	return nil
}

const getQuery = `
	SELECT
	id,
	name,
	coalesce(nullif(description, ''), 'Описание отсутсвует') as description,
	rubles,
	pennies,
	quantity,
	created_at,
	updated_at
	FROM product LIMIT $1 OFFSET $2`

func (s *Storage) GetProduct(ctx context.Context, limit, offset int) ([]model.Product, error) {
	rows, err := s.db.Query(ctx, getQuery, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("GetProduct (1): %w", err)
	}
	defer rows.Close()

	var product []model.Product

	for rows.Next() {
		var p model.Product

		if err := rows.Scan(&p.ID, &p.Name, &p.Description, &p.Rubles, &p.Pennies, &p.Quantity, &p.CreatedAt, &p.UpdatedAt); err != nil {
			return nil, fmt.Errorf("GetProduct (2): %w", err)
		}

		product = append(product, p)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("GetProduct (3): %w", err)
	}

	return product, nil
}

const getByIdQuery = `
	SELECT
	id,
	name,
	coalesce(nullif(description, ''), 'Описание отсутсвует') as description,
	rubles,
	pennies,
	quantity,
	created_at,
	updated_at
	FROM product WHERE id = $1`

func (s *Storage) GetProductById(ctx context.Context, id int) (*model.Product, error) {
	if cacheData, found := s.cache.Get(strconv.Itoa(id)); found {
		s.logger.Info("Data from cache")
		return cacheData.(*model.Product), nil
	}

	var p model.Product
	err := s.db.QueryRow(ctx, getByIdQuery, id).Scan(&p.ID, &p.Name, &p.Description, &p.Rubles, &p.Pennies, &p.Quantity, &p.CreatedAt, &p.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("GetProductByID: %w", err)
	}
	return &p, err
}

const deleteQuery = `DELETE FROM product WHERE id = $1`

func (s *Storage) DeleteProduct(ctx context.Context, id int) error {
	isExist, err := s.CheckIdOnExist(ctx, id)
	if err != nil {
		return fmt.Errorf("DeleteProduct (1): %w", err)
	}

	if !isExist {
		return fmt.Errorf("DeleteProduct (2): %w", ErrProductNotFound)
	}

	_, err = s.db.Exec(ctx, deleteQuery, id)
	if err != nil {
		return fmt.Errorf("DeleteProduct (3): %w", err)
	}

	s.cache.Delete(strconv.Itoa(id))
	s.GetAllProduct(ctx, s.db)

	return nil
}

const createQuery = `
	INSERT INTO product(
		name,
		description,
		rubles,
		pennies,
		quantity,
		created_at,
		updated_at)
	VALUES($1, $2, $3, $4, $5, $6, $7)`

func (s *Storage) CreateProduct(ctx context.Context, product *model.Product) error {
	_, err := s.db.Exec(ctx, createQuery,
		product.Name,
		product.Description,
		product.Rubles,
		product.Pennies,
		product.Quantity,
		product.CreatedAt,
		product.UpdatedAt,
	)
	if err != nil {
		return fmt.Errorf("CreateProduct: %w", err)
	}

	s.GetAllProduct(ctx, s.db)

	return nil
}

const updateQuery = `
	UPDATE product SET
	name = $1,
	description = $2,
	rubles = $3,
	pennies = $4,
	quantity = $5,
	updated_at = $6
	WHERE id = $7`

func (s *Storage) UpdateProduct(ctx context.Context, product *model.Product) error {
	isExist, err := s.CheckIdOnExist(ctx, product.ID)
	if err != nil {
		return fmt.Errorf("UpdateProduct (1): %w", err)
	}

	if !isExist {
		return fmt.Errorf("UpdateProduct (2): %w", ErrProductNotFound)
	}
	_, err = s.db.Exec(ctx, updateQuery,
		product.Name,
		product.Description,
		product.Rubles,
		product.Pennies,
		product.Quantity,
		product.UpdatedAt,
		product.ID,
	)
	if err != nil {
		return fmt.Errorf("UpdateProduct (3): %w", err)
	}

	s.GetAllProduct(ctx, s.db)

	return nil
}

const checkQuery = `
	SELECT EXISTS(
		SELECT 1
		FROM product
		WHERE id = $1)`

func (s *Storage) CheckIdOnExist(ctx context.Context, id int) (bool, error) {
	var isExist bool
	if err := s.db.QueryRow(ctx, checkQuery, id).Scan(&isExist); err != nil {
		return false, fmt.Errorf("CheckID: %w", err)
	}

	return isExist, nil
}

func (s *Storage) CacheUpdater(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			s.logger.Info("Updating cache...")
			if err := s.GetAllProduct(ctx, s.db); err != nil {
				s.logger.Error("CacheUpdater: %w", err)
			}
		}
	}
}
